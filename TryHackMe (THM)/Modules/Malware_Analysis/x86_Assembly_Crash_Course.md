# x86 Assembly Crash Course

A crash course in x86 assembly to enable us in malware reverse engineering.

**Link** - [https://tryhackme.com/r/room/x86assemblycrashcourse](https://tryhackme.com/r/room/x86assemblycrashcourse)

## Task 1: Introduction

The assembly language is the lowest level of human-readable language. It is also the highest level of language into which a binary can be reliably decompiled. When learning malware reverse engineering, knowing the basics of assembly language is essential. This is because when we get a malware sample to analyze, it is most likely a compiled binary. We cannot view this binary's C/C++ or other language code because that is not available to us. What we can do, however, is to decompile the code using a decompiler or a disassembler. The problem with decompiling is that a lot of information in the written code is removed while it is compiled into a binary; hence we won't see variable names, function names, etc., as we do while writing code. So the most reliable code we have for a compiled binary is its assembly code. In this room, we will learn the basics of assembly that we can use in the malware analysis rooms to understand what a binary is doing while looking at its assembly code.

**Learning Objectives**

We will be covering the following topics:

- Opcodes and operands
- General assembly instructions
- Arithmetic and logical instructions
- Conditionals
- Branching instructions

**Prerequisites**

Before starting this room, it is highly recommended that you complete the [x86 Architecture Overview](x86_Architecture_Overview.md) room first.

Answers:

I have completed the prerequisite room.

> No answer needed.

## Task 2: Opcodes and Operands

The code for a program, as written on the disk and understood by the CPU, is in binary format. This means that the actual code is a sequence of 1s and 0s. To make it understandable, we often club a series of 8-bits (called a byte) into a single digit in hex. So the instructions that a computer is executing will be just a sequence of random numbers in hex to a human. Among these random numbers are opcodes and operands. Opcodes denote the hex for actual operations, and operands are the registers or memory locations on which the operations are performed.

Answers:

What are the hex codes that denote the assembly operations called?

> Opcodes

Which type of operand is denoted by square brackets?

> Memory Operand

## Task 3: General Instructions

Instructions tell the CPU what operation to perform. Instructions often use operands from registers, memory, or immediate operands to perform operations and then store the results in either registers or memory. In this task, we will learn the most common instructions that we might come across while reverse engineering malware.

Answers:

In mov eax, ebx, which register is the destination operand?

> EAX

What instruction performs no action?

> NOP

## Task 4: Flags

In x86 assembly language, the CPU has several flags that indicate the outcome of certain operations or conditions. These flags are bits in a special register known as the **flags register** or **EFLAGS** register. Each flag represents a specific condition or result of the most recent arithmetic or logical operation. Hereâ€™s a table with the most common flags in x86 assembly and their explanations:

| **Flag** | **Abbreviation** | **Explanation** |
| :---: | :---: | :---: |
| Carry | CF | Set when a carry-out or borrow is required from the most significant bit in an arithmetic operation. Also used for bit-wise shifting operations.|
| Parity | PF | Set if the least significant byte of the result contains an even number of 1 bits. |
| Auxiliary | AF | Set if a carry-out or borrow is required from bit 3 to bit 4 in an arithmetic operation (BCD arithmetic). |
| Zero | ZF | Set if the result of the operation is zero. |
| Sign | SF | Set if the result of the operation is negative (i.e., the most significant bit is 1). |
| Overflow | OF | Set if there's a signed arithmetic overflow (e.g., adding two positive numbers and getting a negative result or vice versa). |
| Direction | DF | Determines the direction for string processing instructions. If DF=0, the string is processed forward; if DF=1, the string is processed backward. |
| Inturrupt Enable | IF | If set (1), it enables maskable hardware interrupts. If cleared (0), interrupts are disabled. |

Flags can be used in conditional jumps and are crucial for implementing conditional branching in assembly code. For example, you might only jump to a specific address if a certain flag is set or cleared.

Answers:

Which flag will be set if the result of the operation is zero? (Answer in abbreviation)

> ZF

Which flag will be set if the result of the operation is negative? (Answer in abbreviation)

> SF

## Task 5: Arithmetic and Logitcal Instructions

Arithmetic Operations are performed by a CPU using arithmetic instructions. In this task, we will go through these instructions.

Answers:

In a subtraction operation, which flag is set if the destination is smaller than the subtracted value?

> Carry Flag

Which instruction is used to increase the value of a register

> INC

Do the following instructions have the same result? (yea/nay)

`xor eax, eax`

`mov eax, 0`

> YEA

## Task 6: Conditionals and Branching

A CPU often must determine if two values are equal to, greater than, or less than each other. To perform such operations, the CPU uses some conditional instructions. This task will discuss conditional instructions in the x86 assembly language.

Answers:

Which flag is set as a result of the test instruction being zero?

> Zero Flag

Which of the below operations uses subtraction to test two values? 1 or 2?

1. cmp eax, ebx

2. test eax, ebx

> 1

Which flag is used to identify whether a jump will be taken or not after a jz or jnz instruction?

> Zero Flag

## Task 7: Stack and Function Calls

In the x86 Architecture Overview room, we learned about the stack and its significance. We also learned about some of the registers used to reference the location of the stack in the memory. The stack is a Last In, First Out (LIFO) memory. This means the last variable pushed onto the stack is the first to pop out. These push and pop operations are performed by following instructions in the assembly language.

Answers:

Which instruction is used for performing a function call?

> CALL

Which instruction is used to push all registers to the stack?

> PUSHA

## Task 8: Practice Time

So far, we have learned about some common assembly instructions. It's time to practice those instructions using our Assembly Emulator.
Click on the View Site button on the top-right side of this task. It will open a lab in the split screen. For more convenience using full screen, you can click here to open it in a new tab. Please take the guided tour for an overview. After that, follow and run the instructions to observe the stack, memory, registers, and flags.

The options on the top bar can be used to:

- Run the program
- Execute the next instruction
- Stop the execution
- Restart the program

Answers:

While running the MOV instructions, what is the value of [eax] after running the 4th instruction? (in hex)

> 0x00000040

What error is displayed after running the 6th instruction from the MOV instruction section?

> Memory to memory data movement is not allowed.

Run the instructions from the stack section. What is the value of eax after the 9th instruction? (in hex)

> 0x00000025

Run the instructions from the stack section. What is the value of edx after the 12th instruction? (in hex)

> 0x00000010

Run the instructions from the stack section. After POP ecx, what is the value left at the top of the stack? (in hex)

> 0x00000010

Run the cmp and test instructions. Which flags are triggered after the 3rd instruction?
(Note: Use these abbreviations in alphabetical order with no spaces: CF,PF,SF,ZF)

> PF,ZF

Run the test and the cmp instructions. Which flags are triggered after the 11th instruction?
(Note: Use these abbreviations in alphabetical order with no spaces: CF,PF,SF,ZF)

> CF,SF

Run the instructions from the lea section. What is the value of eax after running the 9th instruction? (in hex)

> 0x0000004B

Run the instructions from the lea section. What is the final value found in the ECX register? (in hex)

> 0x00000045

## Task 9: Conclusion

In this room, we covered some of the most commonly used instructions in x86 assembly language. Though there are many other instructions, we covered the ones that briefly overview how operations are performed in the assembly language. As we move forward to other rooms in this module, we will learn about some more instructions as per requirements. In this room, we have covered the following:

- Opcodes and how we convert them into the assembly language.
- General instructions such as move, load effective address, shift and rotate.
- Arithmetic instructions such as addition, subtraction, multiplication, and division.
- Conditionals and how we use them for branching.
- Stack, the push and pop instructions, and function calls.

Answers:

Join the discussion on our social channels.

> No answer needed.
